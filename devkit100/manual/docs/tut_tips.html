<html>
<head>
<link rel="stylesheet" type="text/css" href="style.css">

<title></title>

</head>

<body>

<p align=center>〜tips〜</p>

<p class=midasi2>ゲージ増加処理</p>
<p class=nakami>
　ゲージ増加処理は AddPowerGauge 関数で行うことができますが、それをいつやればいいのかっていう話で、普通はTouchB関数をオーバーライドして処理を行います。この関数は自分の攻撃が敵に当たったときに呼ばれる関数で、ヒットしたときの攻撃情報(ATTACKINFO構造体のポインタ)と、ヒットしたのかガードされたのかのフラグが渡されるので、適当に処理を行ってください。　通常は攻撃情報に設定したユーザーIDを判断材料にしてゲージの増加量を決定します。<br>
　ベース側の処理ではこの関数内で攻撃力のOFF処理を行っているので、最後にベースの関数をコールしてください。
</p>

<p class=midasi2>ゲージ消費技</p>
<p class=nakami>
　該当する行動関数中の特定カウンタ時点で AddPowerGauge関数 をマイナス値で実行すればいいです。<br>
　ゲージがあるときにしか出せないようにするには、Command系関数中の行動遷移の部分に、pdat->gauge に関する条件を追加してください。コンピュータ側も同様にゲージ値のチェック処理を追加する必要があります。
</p>

<p class=midasi2>多段ヒット</p>
<p class=nakami>
　StartAttack関数 をタイミングをずらして複数回実行する
</p>

<p class=midasi2>ガードポイントのある技を作りたい</p>
<p class=nakami>
　TouchAをオーバーライドします。<br>
　TouchAは相手の攻撃が自分に当たったときに呼ばれる関数で、この関数の戻り値によってガードするか、喰らうかを決定しています。TouchAで返すことのできる戻り値定数に関しては gobject.h の TOUCHA_〜 定数定義を参照してください。<br>
　かならず最後にベース側の処理（ガード判定）をコールするのを忘れないでください。
</p>

<p class=midasi2>ガードキャンセル</p>
<p class=nakami>
　喰らいやガードの行動IDが gobject.h で定義されているので、それを参照して Command 系関数の適切な位置に行動遷移のコードを追加してください。
</p>

<p class=midasi2>途中から空中に飛び上がる技があるんだが</p>
<p class=nakami>
　行動IDを決めるとき普通は空中に飛び上がる技は空中扱いのフラグをつけますが、同じ技の途中に地上にいる状態がある場合、その時点で攻撃を喰らうと空中くらい行動に遷移してしまって（相手の）連続技がつながらなくなります。そういう場合はひとつの技でも複数の行動IDに分けといたほうがいいでしょう。<br>
　攻撃のモーションがすごく長い技とかも同様です。ひとつの行動関数が短くなってみやすくなって作りやすくなると思います。
</p>

<p class=midasi2>レイクみたいな連続入力技をうまくコンピュータに出させたいんだが</p>
<p class=nakami>
　第一には、COM用に一連の技を連続で出すような別の行動と行動IDを用意して対処します。<br>
<br>
　第二にはCOMの行動遷移を制御する関数を使用します。CGoluahObject::SetComAct関数により、
次に起こすべき行動の行動IDを指定します。ここで指定するIDは技情報構造体で指定するIDに
含まれていない値を指定してもかまいません。
</p>

<p class=midasi2>複数対戦のとき、何人もの相手にぼこぼこ当たるような技をつくる</p>
<p class=nakami>
　TouchCを使います。<br>
　TouchCは自分の攻撃が相手に当たった（と、システム側で判定された）とき、相手側へのTouchAメッセージ送信と、自分側へのTouchB送信よりも前に送信されるメッセージ処理関数で、この関数で適切な戻り値（gobject.h参照。TOUCHC_〜定数）を返すことによって当たり判定（矩形の衝突）をなかったことにできます。<br>
<br>
　やり方：<br>
　まず、TouchB中で、問題の攻撃が当たったときには攻撃力のOFF処理をしないようにしときます。そんで、TouchCで引数に喰らったヤツのオブジェクトIDが渡されるので、それをリストに管理して一度当たったやつが再度当たったときには衝突をなかったことにします。当然適切なタイミングでリストのクリアも忘れずに。<br>
<br>
 また、タイトルとは趣旨がずれますが、このメッセージを処理することによって相手のとっている行動にあわせて攻撃力を再設定することができます（空中で喰らったときと、地上で喰らったときで喰らい動作フラグを変更するとか）
</p>

<p class=midasi2>相手の位置が知りたい</p>
<p class=nakami>
　pdat->eid （「敵」のオブジェクトID）　と　GetInfo関数　を使います。<br>
　GetInfoで敵の情報（GOBJECT構造体）が取得できるので、その x,y 座標で相手の位置を知ることができます。<br>
　自分の座標 pdat->x , y と比較することによって間合いの判定ができることはいうまでもない。いってるけど。ただし、これだけで間合いを計算して投げ判定をやるのはお勧めしません。なぜなら重なり判定のでかいキャラが投げられなくなるから。
</p>

<p class=midasi2>攻撃ヒットで技発動</p>
<p class=nakami>
　TouchB中で判断して行動遷移
</p>

<p class=midasi2>飛び道具のヒットタイミング取得</p>
<p class=nakami>
　飛び道具オブジェクトのTouchBイベントを取得して、キャラクタにユーザー定義メッセージを送信（=キャラクターオブジェクトのメッセージ処理関数を、そのIDを引数としてコールする）してください。ユーザー定義メッセージは他のメッセージと値がかぶらないように、GOBJMSG_USERDEFINE + 適当な通し番号　で定義します。<br>
　飛び道具がCBulletBase継承クラスであれば、SetHitMessage 、SetGuardMessage でそれぞれヒット、ガード時のメッセージが設定でき、ヒット・ガード時に自動的にキャラクタークラスのMessage関数をコールするので、キャラクタークラスのMessage関数で該当メッセージを拾ってください。飛び道具ヒット時のゲージ増加はこの手順で行う必要があります。
</p>

<hr><p align="center"><a href="../index.html">もどる</a></p>
</body>
